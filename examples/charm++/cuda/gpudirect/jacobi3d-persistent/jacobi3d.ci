mainmodule jacobi3d {
  include "jacobi3d.h";

  readonly CProxy_Main main_proxy;
  readonly CProxy_Block block_proxy;
  readonly int num_chares;
  readonly int grid_width;
  readonly int grid_height;
  readonly int grid_depth;
  readonly int block_width;
  readonly int block_height;
  readonly int block_depth;
  readonly size_t x_surf_size;
  readonly size_t y_surf_size;
  readonly size_t z_surf_size;
  readonly int n_chares_x;
  readonly int n_chares_y;
  readonly int n_chares_z;
  readonly int n_iters;
  readonly int warmup_iters;
  readonly bool use_zerocopy;
  readonly bool use_persistent;
  readonly bool print_elements;

  message PersistentMsg;

  mainchare Main {
    entry Main(CkArgMsg* m);
    entry [reductiontarget] void initDone();
    entry void startIter();
    entry [reductiontarget] void warmupDone();
    entry [reductiontarget] void allDone();
    entry void printDone();
  };

  array [3D] Block {
    entry Block(void);
    entry void init();
    entry void initRecv(int dir, CkDevicePersistent p_buf);
    entry void update();
    entry void packGhosts();
    entry void packGhostsDone();
    entry void recvGhostZC(int ref, int dir, int w, nocopydevice DataType gh[w]);
    entry void recvGhostP(PersistentMsg* msg);
    entry void sendGhostP() {} // TODO
    entry void recvGhostReg(int ref, int dir, int w, DataType gh[w]);

    entry void initDone() {
      if (use_persistent) {
        for (remote_count = 0; remote_count < neighbors; remote_count++) {
          when initRecv(int dir, CkDevicePersistent p_buf) {
            serial {
              p_neighbor_bufs[dir] = p_buf;
            }
          }
        }
      }

      serial {
        contribute(CkCallback(CkReductionTarget(Main, initDone), main_proxy));
      }
    }

    entry void exchangeGhosts() {
      serial {
        my_iter++;
        update();
        packGhosts();
      }

      when packGhostsDone() {
        serial {
          // When packing is done, we know that the new temperatures have been updated
          // (because the host doesn't separately detect when the Jacobi kernel completes)
          std::swap(d_temperature, d_new_temperature);
          sendGhosts();
        }
      }

      for (remote_count = 0; remote_count < neighbors; remote_count++) {
        if (use_zerocopy) {
          when recvGhostZC[my_iter](int ref, int dir, int w, nocopydevice DataType buf[w]) {
            serial {
              processGhostZC(dir, w, buf);
            }
          }
        } else if (use_persistent) {
          overlap {
            when recvGhostP[my_iter](PersistentMsg* msg) serial {
              processGhostP(msg);
            }
            // TODO: Add this back in once hang with reference numbers in CkCallback is fixed
            /*
            when sendGhostP[my_iter]() serial {
              CkPrintf("Chare %d, iter %d: Received sendGhostP\n", thisIndex.z, my_iter);
            }
            */
          }
        } else {
          when recvGhostReg[my_iter](int ref, int dir, int w, DataType buf[w]) {
            serial {
              processGhostReg(dir, w, buf);
            }
          }
        }
      }

      serial {
        if (my_iter <= warmup_iters) {
          contribute(CkCallback(CkReductionTarget(Main, warmupDone), main_proxy));
        } else {
          if (my_iter < warmup_iters + n_iters) {
            thisProxy[thisIndex].exchangeGhosts();
          } else {
            contribute(CkCallback(CkReductionTarget(Main, allDone), main_proxy));
          }
        }
      }
    }

    entry void print();
  };
};
