module CkIO {

  namespace Ck { namespace IO {
      message FileReadyMsg;
      message SessionReadyMsg;
      message SessionCommitMsg;
      message ReadCompleteMsg{
		char data[];
      }; // used by the read() CkCallback 
    }
  }

  initnode _registerCkIO_impl();
};

module CkIO_impl {
  include "ckio.h";

  namespace Ck { namespace IO {
      namespace impl {
        readonly CProxy_Director director;

        mainchare [migratable] Director
        {
          entry Director(CkArgMsg *);

          /// Serialize setting up each file through this chare, so that all PEs
          /// have the same sequence
          entry void openFile(std::string name, CkCallback opened, Options opts);
          entry [reductiontarget] void fileOpened(FileToken file);
          entry [reductiontarget] void sessionComplete(FileToken file);
	  // facilitates all of the read calls that will happen
	  
//	  entry void read(Session session, size_t bytes, size_t offset, CkCallback after_read);

//	  entry void read(Session session, size_t bytes, size_t offset, CkCallback after_read, size_t tag);
	// this method is called by the read function by the user in order to get data
	
	// the method used by the director which is used to close a readsession
	  entry void closeReadSession(Session, CkCallback);

	  entry void prepareReadSession(FileToken file, size_t bytes, size_t offset, CkCallback ready){ // the director sets up a read session
		serial {
			prepareReadSessionHelper(file, bytes, offset, ready);
		}
		when sessionReady[files[file].sessionID](CkReductionMsg* m) serial { // after the ReadSession chare array is set up, invoke the ready callback
			delete m;
			Session s(file, bytes, offset, files[file].read_session);
			CProxy_ReadAssembler ra = CProxy_ReadAssembler::ckNew(s);
			managers.addSessionReadAssemblerMapping(s, ra, ready);	
		}
	  };
          entry void prepareWriteSession(FileToken file, size_t bytes, size_t offset,
                                         CkCallback ready, CkCallback complete) {
            serial {
              prepareWriteSession_helper(file, bytes, offset, ready, complete);
            }
            when sessionReady[files[file].sessionID](CkReductionMsg *m) serial {
              delete m;
              ready.send(new SessionReadyMsg(Session(file, bytes, offset,
                                                     files[file].session)));
            }
          };
          entry void prepareWriteSession(FileToken file, size_t bytes, size_t offset,
                                         CkCallback ready, const char commitData[commitBytes],
                                         size_t commitBytes, size_t commitOffset,
                                         CkCallback complete) {
            serial {
              CkCallback committed(CkIndex_Director::sessionDone(NULL), thisProxy);
              committed.setRefnum(++sessionID);
              prepareWriteSession_helper(file, bytes, offset, ready, committed);
            }
            when sessionReady[files[file].sessionID](CkReductionMsg *m) serial {
              delete m;
              ready.send(new SessionReadyMsg(Session(file, bytes, offset,
                                                     files[file].session)));
            }
            when sessionDone[files[file].sessionID](CkReductionMsg *m) serial {
              delete m;
              impl::FileInfo* info = CkpvAccess(manager)->get(file);
              CmiInt8 ret = CmiPwrite(info->fd, commitData, commitBytes, commitOffset);
              if (ret != commitBytes)
                fatalError("Commit write failed", info->name);
              complete.send(CkReductionMsg::buildNew(0, NULL, CkReduction::nop));
            }
          };

	  entry[reductiontarget] void addSessionReadAssemblerCallback(std::pair<Ck::IO::Session, CkCallback> pair) {
		serial {
			CkPrintf("Finished the reduction for adding the session\n");
			SessionReadyMsg* msg = new SessionReadyMsg(pair.first);
			CkAssert(msg);
			pair.second.send(msg);		
			delete msg;
		}
	  };
          entry void sessionReady(CkReductionMsg *);
          entry void sessionDone(CkReductionMsg *);
          entry void close(FileToken token, CkCallback closed);
        }

	// class tht will be used to assemble a specific read call
	group ReadAssembler {
		 // stores the parameters of the read call it is tasked with building
		entry ReadAssembler(Session session);
		
			
		// the method by which ReadSession objects can send their data for the read	
		// when invoked, avoid a sender-side copy	
		entry /*[inline]*/ void shareData(int read_tag, int buffer_tag, size_t read_chare_offset, size_t num_bytes, nocopypost char data[num_bytes]); 

		entry void serveRead(size_t read_bytes, size_t read_offset, CkCallback after_read, size_t read_stripe); // will be used to serve the read_stripe

	};


        group [migratable] Manager
        {
          entry Manager();
          entry void run() {
            while (true) {
              case {
                when openFile[opnum](unsigned int opnum_,
                                     FileToken token, std::string name, Options opts)
                  serial { prepareFile(token, name, opts); }
                when close[opnum](unsigned int opnum_, FileToken token, CkCallback closed)
                  serial { doClose(token, closed); }
              }
              serial { opnum++; }
            }
          };
          entry void openFile(unsigned int opnum,
                              FileToken token, std::string name, Options opts);
          entry void close(unsigned int opnum, FileToken token, CkCallback closed);

	  entry void addSessionReadAssemblerMapping(Session session, CProxy_ReadAssembler ra, CkCallback ready);
        };

        array [1D] WriteSession
        {
          entry WriteSession(FileToken file, size_t offset, size_t bytes);
          entry void forwardData(const char data[bytes], size_t bytes, size_t offset);
          entry void syncData();
        };
	

	array [1D] ReadSession {
		entry ReadSession(FileToken file, size_t offset, size_t bytes);
		// way for the ReadSession object to send bytes over to the ReadAssembler object ra when serving a specific read
		entry void sendData(int read_tag, int buffer_tag, size_t offset, size_t bytes, CProxy_ReadAssembler ra, int pe); 
		entry void clearBuffer();
		entry [reductiontarget] void printTime(double time_taken);

		entry void zeroCopyCallback(size_t offset, double time);
	};
        
	group Map : CkArrayMap
        {
          entry Map();
        };
      }
    }
  }
}
