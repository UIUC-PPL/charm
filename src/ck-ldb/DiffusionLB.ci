module DiffusionLB {

  include "CentralLBMsg.h";
  extern module DistBaseLB;
  initnode void lbinit(void);

  group DiffusionLB: DistBaseLB {
    entry void DiffusionLB(const CkLBOptions &);
    entry [reductiontarget] void PEStarted();
    entry [reductiontarget] void createNeighbors();
    entry void AddNeighbor(int node);
    entry void AtSync(void);
    entry void ProcessAtSync(void);
    entry void doneNborExng();
    entry void ReceiveLoadInfo(int itr, double load, int node);
    entry void ReceiveStats(CkMarshalledCLBStatsMessage data);
    //entry void LoadTransfer(double load, int initPE, int objId);
    entry void LoadReceived(int objId, int fromPE);
    //entry [reductiontarget] void DoneNodeLB();
    entry void MigratedHelper(LDObjHandle h, int waitBarrier);
    entry void MigrationEnded();
    entry void LoadMetaInfo(LDObjHandle h, double load);
    entry void MigrationDone();  // Call when migration is complete

    //entry void MigrationInfo(int to, int from);
    entry void ResumeClients(CkReductionMsg *msg);
    entry void ResumeClients(int balancing);
    
    entry void PseudoLoad(int itr, double load, int node); 
    entry void CallResumeClients();
    entry void PrintDebugMessage(int len, double result[len]);
    entry void notifyNeighbor(int isNbor, int node) {
//inc neighbor count upto 2xK
    serial {
      int toAdd = 0;
      
      if(isNbor) {
        toAdd = 1;
        CkPrintf("\n[PE-%d] going over %d nbors", CkMyPe(), neighborCount);
        for(int k=0;k<neighborCount;k++)
          if(nbors[k] == node) {
            toAdd = 0;
            break;
          }
      }

      if(toAdd) {
        CkPrintf("\n[PE-%d]Adding %dth nbor node %d to me", CkMyPe(), neighborCount,node);
//        if(neighborCount<NUM_NEIGHBORS)
          nbors[neighborCount++] = node;
      }
      notif++;
      if(notif == CkNumNodesDiff()) {
        for(int k=0;k<neighborCount;k++)
          CkPrintf("\n[PE-%d], my largest comm %dth neighbors are %d\n", CkMyPe(), k, nbors[k]);
//        notif = 0;
        doneNborExng();
      } 
      else if(notif > CkNumNodesDiff())
        CkPrintf("\nToo many notificaations!! [PE-%d]", CkMyPe());
      else
        CkPrintf("\n[PE-%d,Node-%d] receieved %dth notification from node-%d", CkMyPe(), CkMyNodeDiff(), notif,node);
    }
    };
    
    entry void iterate() {

        //TODO: Currently fixed iterations
        for(itr = 0; itr < ITERATIONS; itr++) {
            // Send its load
            serial "Send loadInfo" {
                if(CkMyPe()==0)
                  CkPrintf("\n---------------------------------------------------------------------------------------------\n");
//                CkPrintf("\n[Node-%d], sendToNeighbors.size = %lu", CkMyNodeDiff(), neighborCount);
                for(int i = 0; i < neighborCount; i++) {
                    CkPrintf("\n[%d] itr-%d Sending load info to node-%d \n", CkMyPe(), itr, sendToNeighbors[i]);
                    thisProxy[CkNodeFirstDiff(sendToNeighbors[i])].ReceiveLoadInfo(itr, my_load, CkMyNodeDiff());
                }         
                 
            }
             
            // Wait for all its neighbors load
            for(temp_itr = 0; temp_itr < neighborCount; temp_itr++) {
                when ReceiveLoadInfo[itr](int itr, double load, int node) serial
                {
                  //if(itr == 0 || itr == ITERATIONS-1)
                  {
                    CkPrintf("\n[Pe-%d (node-%d) itr-%d] recvd load from node-%d\n",
                                               CkMyPe(), CkMyNodeDiff(), itr, node);
                  }
                  int pos1 = findNborIdx(node);
                  CkPrintf("\n[PE-%d]pos = %d(//%d)", CkMyPe(), pos1,neighborCount-1);
                  if(pos1 < 0 || pos1 >= CkNumNodesDiff())
                    CkPrintf("\nError in pos %d", pos1);
                  loadNeighbors[pos1] = load;
                }
            }

            // Calculate average and do pseudo load balancing
            serial "Pseudo LB" {
                avgLoadNeighbor = average();
                CkPrintf("[PE-%d] Received all loads of node, avg is %f and my_load %f \n", CkMyPe(), avgLoadNeighbor, my_load);
                PseudoLoadBalancing();
            }

            for(temp_itr = 0; temp_itr < toSend; temp_itr++) {
                when PseudoLoad[itr](int itr, double load, int node) serial {
//                    if(load > 0)
                        CkPrintf("[%d] GRD itr %d : Pseudo load received %f from node %d/%d \n",
                                          CkMyPe(), itr, load, node, toSend);
                    my_load += load;
                    int pos = findNborIdx(node);
                    CkPrintf("\n[PE-%d]pos = %d", CkMyPe(), pos);
                    if(pos < 0 || pos >= CkNumNodesDiff())
                      CkPrintf("\nError in pos %d", pos);
                    toReceiveLoad[pos] += load;
                }
            }
            
        }

        // Calculate the aggregate load that has to be sent.
        serial {
            bool res = AggregateToSend();
            actualSend = 0;
            // Only if this node should send load, call load balancing
            if(res || _lb_args.debug()) {
                LoadBalancing();
            }
            CkPrintf("\n[PE-%d,node-%d]Calling DoneNodeLB", CkMyPe(), CkMyNodeDiff());
            DoneNodeLB();
            my_load = my_loadAfterTransfer;
        }
    }
  };

};

