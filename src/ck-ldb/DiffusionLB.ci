module DiffusionLB {

  include "CentralLBMsg.h";
  include "Diffusion.h";
  readonly  CProxy_Diffusion diff_array;
  extern module Diffusion;
  extern module DistBaseLB;
  initnode void lbinit(void);

  group DiffusionLB: DistBaseLB {
    entry void DiffusionLB(const CkLBOptions &);
    entry [reductiontarget] void MaxLoad(double val);
    entry [reductiontarget] void AvgLoad(double val);
    entry [reductiontarget] void SumIntBytes(long val);
    entry [reductiontarget] void SumExtBytes(long val);
    entry [reductiontarget] void createNeighbors();
    entry void AddNeighbor(int node);
    entry void collectStats(int nodeId, long internalBytes, long externalBytes);
    entry void continueLB();
    entry void AtSync(void);
    entry void ProcessAtSync(void);
    entry void doneNborExng();
    entry void ReceiveStats(CkMarshalledCLBStatsMessage data);
    entry void LoadReceived(int objId, int fromPE);
    entry void MigratedHelper(LDObjHandle h, int waitBarrier);
    entry void MigrationEnded();
    entry void LoadMetaInfo(LDObjHandle h, double load);
    entry void MigrationDone();  // Call when migration is complete

    entry void ResumeClients(CkReductionMsg *msg);
    entry void ResumeClients(int balancing);
    
    entry void CallResumeClients();
    entry void notifyNeighbor(int isNbor, int node) {
    //inc neighbor count upto 2xK
    serial {
      int toAdd = 0;
      
      if(isNbor) {
        toAdd = 1;
        for(int k=0;k<neighborCount;k++)
          if(nbors[k] == node) {
            toAdd = 0;
            break;
          }
      }

      if(toAdd) {
        DEBUGL(("\n[PE-%d]Adding %dth nbor node %d to me", CkMyPe(), neighborCount,node));
        nbors[neighborCount++] = node;
      }
      notif++;
      if(notif == CkNumNodesDiff()) {
//        notif = 0;
        doneNborExng();
      } 
      else if(notif > CkNumNodesDiff())
        DEBUGL(("\nToo many notificaations!! [PE-%d]", CkMyPe()));
//      else
//        DEBUGL(("\n[PE-%d,Node-%d] receieved %dth notification from node-%d", CkMyPe(), CkMyNodeDiff(), notif,node);
    }
    };
/*    
    entry void resumeLB() {

        // Calculate the aggregate load that has to be sent.
        serial {
            bool res = AggregateToSend();
            actualSend = 0;
            // Only if this node should send load, call load balancing
            //if(res || _lb_args.debug())
            {
                LoadBalancing();
            }
//            DEBUGL(("\n[PE-%d,node-%d]Calling DoneNodeLB", CkMyPe(), CkMyNodeDiff());
//            DoneNodeLB();
            //DoneNodeLB();
            //my_load = my_loadAfterTransfer;
        }
    }
*/
  };

};

